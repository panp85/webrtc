{
  "methods": {
    "addGpsStatusListener(android.location.GpsStatus.Listener)": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [
        "listener"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "addGpsStatusListener(android.location.GpsStatus.Listener)"
    },
    "addLocationListener(java.lang.String,android.location.LocationListener,long,float)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "provider",
        "listener",
        "minTime",
        "minDistance"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "addLocationListener(java.lang.String,android.location.LocationListener,long,float)"
    },
    "cleanupRemovedLocationListeners()": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [],
      "returnType": "void",
      "exceptions": [],
      "name": "cleanupRemovedLocationListeners()"
    },
    "copyOf(android.location.Location)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "location"
      ],
      "returnType": "android.location.Location",
      "exceptions": [],
      "name": "copyOf(android.location.Location)"
    },
    "distanceBetween(android.location.Location,android.location.Location)": {
      "isImplementation": false,
      "modifiers": [
        "private",
        "static"
      ],
      "params": [
        "location1",
        "location2"
      ],
      "returnType": "float",
      "exceptions": [],
      "name": "distanceBetween(android.location.Location,android.location.Location)",
      "documentation": "Returns the distance between the two locations in meters.\nAdapted from: http://stackoverflow.com/questions/837872/calculate-distance-in-meters-when-you-know-longitude-and-latitude-in-java\n"
    },
    "getAllProviders()": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "java.util.List\u003cjava.lang.String\u003e",
      "exceptions": [],
      "name": "getAllProviders()"
    },
    "getBestProvider(android.location.Criteria,boolean)": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [
        "criteria",
        "enabled"
      ],
      "returnType": "java.lang.String",
      "exceptions": [],
      "name": "getBestProvider(android.location.Criteria,boolean)"
    },
    "getBestProviderWithCriteria(android.location.Criteria,boolean)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "criteria",
        "enabled"
      ],
      "returnType": "java.lang.String",
      "exceptions": [],
      "name": "getBestProviderWithCriteria(android.location.Criteria,boolean)"
    },
    "getBestProviderWithNoCriteria(boolean)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "enabled"
      ],
      "returnType": "java.lang.String",
      "exceptions": [],
      "name": "getBestProviderWithNoCriteria(boolean)"
    },
    "getLastBestProviderCriteria()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "android.location.Criteria",
      "exceptions": [],
      "name": "getLastBestProviderCriteria()",
      "documentation": "Gets the criteria value used in the last call to {@link #getBestProvider(android.location.Criteria, boolean)}.\n\n@return the criteria used to find the best provider\n"
    },
    "getLastBestProviderEnabledOnly()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "boolean",
      "exceptions": [],
      "name": "getLastBestProviderEnabledOnly()",
      "documentation": "Gets the enabled value used in the last call to {@link #getBestProvider(android.location.Criteria, boolean)}\n\n@return the enabled value used to find the best provider\n"
    },
    "getLastKnownLocation(java.lang.String)": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [
        "provider"
      ],
      "returnType": "android.location.Location",
      "exceptions": [],
      "name": "getLastKnownLocation(java.lang.String)"
    },
    "getProviders(boolean)": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [
        "enabledOnly"
      ],
      "returnType": "java.util.List\u003cjava.lang.String\u003e",
      "exceptions": [],
      "name": "getProviders(boolean)"
    },
    "getProvidersForListener(android.location.LocationListener)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "listener"
      ],
      "returnType": "java.util.Collection\u003cjava.lang.String\u003e",
      "exceptions": [],
      "name": "getProvidersForListener(android.location.LocationListener)"
    },
    "getRequestLocationUdpateCriteriaPendingIntents()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "java.util.Map\u003candroid.app.PendingIntent,android.location.Criteria\u003e",
      "exceptions": [],
      "name": "getRequestLocationUdpateCriteriaPendingIntents()"
    },
    "getRequestLocationUdpateProviderPendingIntents()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "java.util.Map\u003candroid.app.PendingIntent,java.lang.String\u003e",
      "exceptions": [],
      "name": "getRequestLocationUdpateProviderPendingIntents()"
    },
    "getRequestLocationUpdateListeners()": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [],
      "returnType": "java.util.List\u003candroid.location.LocationListener\u003e",
      "exceptions": [],
      "name": "getRequestLocationUpdateListeners()",
      "documentation": "@return lastRequestedLocationUpdatesLocationListener\n"
    },
    "hasGpsStatusListener(android.location.GpsStatus.Listener)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "listener"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "hasGpsStatusListener(android.location.GpsStatus.Listener)"
    },
    "isProviderEnabled(java.lang.String)": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [
        "provider"
      ],
      "returnType": "boolean",
      "exceptions": [],
      "name": "isProviderEnabled(java.lang.String)"
    },
    "removeDuplicates(android.location.LocationListener,java.util.List\u003corg.robolectric.shadows.ShadowLocationManager.ListenerRegistration\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "private"
      ],
      "params": [
        "listener",
        "providerListeners"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "removeDuplicates(android.location.LocationListener,java.util.List\u003corg.robolectric.shadows.ShadowLocationManager.ListenerRegistration\u003e)"
    },
    "removeGpsStatusListener(android.location.GpsStatus.Listener)": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "removeGpsStatusListener(android.location.GpsStatus.Listener)"
    },
    "removeUpdates(android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [
        "pendingIntent"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "removeUpdates(android.app.PendingIntent)"
    },
    "removeUpdates(android.location.LocationListener)": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "removeUpdates(android.location.LocationListener)"
    },
    "requestLocationUpdates(java.lang.String,long,float,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [
        "provider",
        "minTime",
        "minDistance",
        "pendingIntent"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdates(java.lang.String,long,float,android.app.PendingIntent)"
    },
    "requestLocationUpdates(java.lang.String,long,float,android.location.LocationListener)": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [
        "provider",
        "minTime",
        "minDistance",
        "listener"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdates(java.lang.String,long,float,android.location.LocationListener)"
    },
    "requestLocationUpdates(java.lang.String,long,float,android.location.LocationListener,android.os.Looper)": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [
        "provider",
        "minTime",
        "minDistance",
        "listener",
        "looper"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdates(java.lang.String,long,float,android.location.LocationListener,android.os.Looper)"
    },
    "requestLocationUpdates(long,float,android.location.Criteria,android.app.PendingIntent)": {
      "isImplementation": true,
      "modifiers": [
        "public"
      ],
      "params": [
        "minTime",
        "minDistance",
        "criteria",
        "pendingIntent"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "requestLocationUpdates(long,float,android.location.Criteria,android.app.PendingIntent)"
    },
    "setBestProvider(java.lang.String,boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "provider",
        "enabled"
      ],
      "returnType": "boolean",
      "exceptions": [
        "java.lang.Exception"
      ],
      "name": "setBestProvider(java.lang.String,boolean)"
    },
    "setBestProvider(java.lang.String,boolean,java.util.List\u003candroid.location.Criteria\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "provider",
        "enabled",
        "criteria"
      ],
      "returnType": "boolean",
      "exceptions": [
        "java.lang.Exception"
      ],
      "name": "setBestProvider(java.lang.String,boolean,java.util.List\u003candroid.location.Criteria\u003e)",
      "documentation": "Sets the value to return from {@link #getBestProvider(android.location.Criteria, boolean)} for the given\n{@code provider}\n\n@param provider name of the provider who should be considered best\n@param enabled Enabled\n@param criteria List of criteria\n@throws Exception if provider is not known\n@return false If provider is not enabled but it is supposed to be set as the best enabled provider don\u0027t set it, otherwise true\n"
    },
    "setLastKnownLocation(java.lang.String,android.location.Location)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "provider",
        "location"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setLastKnownLocation(java.lang.String,android.location.Location)",
      "documentation": "Sets the value to return from {@link #getLastKnownLocation(String)} for the given {@code provider}\n\n@param provider\n           name of the provider whose location to set\n@param location\n           the last known location for the provider\n"
    },
    "setProviderEnabled(java.lang.String,boolean)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "provider",
        "isEnabled"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setProviderEnabled(java.lang.String,boolean)",
      "documentation": "Sets the value to return from {@link #isProviderEnabled(String)} for the given {@code provider}\n\n@param provider\n           name of the provider whose status to set\n@param isEnabled\n           whether that provider should appear enabled\n"
    },
    "setProviderEnabled(java.lang.String,boolean,java.util.List\u003candroid.location.Criteria\u003e)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "provider",
        "isEnabled",
        "criteria"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "setProviderEnabled(java.lang.String,boolean,java.util.List\u003candroid.location.Criteria\u003e)"
    },
    "simulateLocation(android.location.Location)": {
      "isImplementation": false,
      "modifiers": [
        "public"
      ],
      "params": [
        "location"
      ],
      "returnType": "void",
      "exceptions": [],
      "name": "simulateLocation(android.location.Location)"
    }
  },
  "imports": [
    "android.app.PendingIntent",
    "android.app.PendingIntent.CanceledException",
    "android.content.Intent",
    "android.location.Criteria",
    "android.location.GpsStatus.Listener",
    "android.location.Location",
    "android.location.LocationListener",
    "android.location.LocationManager",
    "android.os.Looper",
    "java.util.ArrayList",
    "java.util.Collection",
    "java.util.HashMap",
    "java.util.HashSet",
    "java.util.Iterator",
    "java.util.LinkedHashMap",
    "java.util.LinkedHashSet",
    "java.util.List",
    "java.util.Map",
    "java.util.Set",
    "org.robolectric.annotation.Implementation",
    "org.robolectric.annotation.Implements",
    "org.robolectric.shadows.ShadowLocationManager.ListenerRegistration",
    "org.robolectric.shadows.ShadowLocationManager.LocationProviderEntry"
  ],
  "name": "org.robolectric.shadows.ShadowLocationManager"
}